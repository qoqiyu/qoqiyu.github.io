[{"title":"Javascript 实现链表","date":"2021-08-21T18:21:29.000Z","date_formatted":{"ll":"Aug 21, 2021","L":"08/21/2021","MM-DD":"08-21"},"updated":"2021-08-21T10:47:09.114Z","content":"总结\n\n构建一个完整的链表，需要创建两个类：Node 节点类和 *LinkedList 链表类\n如此构建的链表有着快捷的 增 删 查 改 的操作\n但内存消耗大，典型的以时间换空间（next 和 prev 的指针域采用套娃的形式连接每一个节点）\n\n代码\nNode 节点类\n12345678910class Node &#123;    constructor(val = 0, next = null, prev = null) &#123;        // 链表数据域        this.val = val        // 链表指针域        this.next = next        // 链表指针域（双向链表）        this.prev = prev    &#125;&#125;\nSingle Linked List 单向链表类\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124class SingleLinkedList &#123;    #head    #currentNode    #size    constructor(head = &#x27;head&#x27;) &#123;        // 表头节点        this.#head = new Node(head)        // 当前节点        this.#currentNode = this.#head        // 链表长度        this.#size = 0    &#125;    // 查找 val 节点    find (val) &#123;        this.#currentNode = this.#head        while (this.#currentNode &amp;&amp; this.#currentNode.val !== val) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    // 查找最后添加的节点    findLasst () &#123;        this.#currentNode = this.#head        while (this.#currentNode.next) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    // 在 prevNode 之后插入 val 节点    insert (val, prevNode) &#123;        this.#currentNode = this.find(prevNode)        if (!this.#currentNode) return console.error(`$&#123;prevNode&#125; is undefined`)        val = new Node(val)        val.next = this.#currentNode.next        this.#currentNode.next = val        this.#size++    &#125;    // 在链表尾部添加 val 节点    append (val) &#123;        this.#currentNode = this.findLasst()        this.#currentNode.next = new Node(val)        this.#size++    &#125;    // 移除 val 节点    remove (val) &#123;        // 移除的节点不存在        if (!this.find(val)) return        // 移除的节点为表头的情况        // 链表长度不为 0 时，直接返回；若删除表头，则将找不到该链表的入口        // 链表长度为 0 时，将表头的 next 指针置空        if (val === this.#head.val) &#123;            if (!this.isEmpty()) &#123;                return            &#125; else &#123;                this.#head.next = null                this.#size = 0                return            &#125;        &#125;        this.#currentNode = this.#head        while (this.#currentNode.next.val !== val) &#123;            if (!this.#currentNode.next) return            this.#currentNode = this.#currentNode.next        &#125;        this.#currentNode.next = this.#currentNode.next.next        this.#size--    &#125;    // 链表是否为空    isEmpty () &#123;        return this.#size === 0    &#125;    // 显示当前的节点    show () &#123;        console.log(this.#currentNode?.val)    &#125;    // 获取链表的长度    getLength () &#123;        return this.#size    &#125;    // 节点指针从 currentNode 位置（默认表头）前进 num 位    forward (num, start) &#123;        this.#currentNode = start ? this.find(start) : this.#currentNode        while (num-- &amp;&amp; this.#currentNode?.next) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    // 返回表头    goToHead () &#123;        this.#currentNode = this.#head    &#125;    // 遍历显示链表    display () &#123;        let result = &#x27;&#x27;        this.#currentNode = this.#head        while (this.#currentNode) &#123;            result += this.#currentNode.val            this.#currentNode = this.#currentNode.next            if (this.#currentNode) result += &#x27;-&gt;&#x27;        &#125;        console.log(result)    &#125;    // 清空链表    clear () &#123;        this.#head.next = null        this.#currentNode = this.#head        this.#size = 0    &#125;&#125;\nDouble Linked List 双向链表类\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137class DoubleLinkedList &#123;    #head    #tail    #currentNode    #size    constructor (head = &#x27;head&#x27;) &#123;        this.#head = new Node(head)        // 表尾        this.#tail = this.#head        this.#currentNode = this.#head        this.#size = 0    &#125;    find (val) &#123;        this.#currentNode = this.#head        while (this.#currentNode &amp;&amp; this.#currentNode.val !== val) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    showLast () &#123;        return this.#tail    &#125;    insert (val, prevNode) &#123;        // preNode 为末尾节点的情况        if (prevNode === this.#tail.val) &#123;            this.#currentNode = new Node(val)            this.#tail.next = this.#currentNode            this.#currentNode.prev = this.#tail            this.#tail = this.#currentNode            this.#size++            return        &#125;        this.#currentNode = this.find(prevNode)        if (!this.#currentNode) return console.error(`$&#123;prevNode&#125; is undefined`)        val = new Node(val)        val.prev = this.#currentNode        val.next = this.#currentNode.next        this.#currentNode.next = val        this.#size++    &#125;    append (val) &#123;        this.#currentNode = new Node(val)        this.#tail.next = this.#currentNode        this.#currentNode.prev = this.#tail        this.#tail = this.#currentNode        this.#size++    &#125;    remove (val) &#123;        // val 节点为末尾的情况        if (val === this.#tail.val) &#123;            this.#currentNode = this.#tail.prev            this.#currentNode.next = null            this.#size--            return        &#125;        if (val === this.#head.val) &#123;            if (!this.isEmpty()) &#123;                return            &#125; else &#123;                this.head.next = null                this.#size = 0                return            &#125;        &#125;        this.#currentNode = this.find(val)        // 移除的节点不存在        if (!this.#currentNode) return        this.#currentNode.next.prev = this.#currentNode.prev        this.#currentNode.prev.next = this.#currentNode.next        this.#size--    &#125;    forward (num, start) &#123;        this.#currentNode = start ? this.find(start) : this.#currentNode        while (num-- &amp;&amp; this.#currentNode?.next) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    back (num, start) &#123;        this.#currentNode = start ? this.find(start) : this.#currentNode        while (num-- &amp;&amp; this.#currentNode?.prev) &#123;            this.#currentNode = this.#currentNode.prev        &#125;        return this.#currentNode    &#125;    goToHead () &#123;        this.#currentNode = this.#head    &#125;    goToTail () &#123;        this.#currentNode = this.#tail    &#125;    isEmpty () &#123;        return this.#size === 0    &#125;    show () &#123;        console.log(this.#currentNode?.val)    &#125;    getLength () &#123;        return this.#size    &#125;    display () &#123;        let result = &#x27;&#x27;        this.#currentNode = this.#head        while (this.#currentNode) &#123;            result += this.#currentNode.val            this.#currentNode = this.#currentNode.next            if (this.#currentNode) result += &#x27;-&gt;&#x27;        &#125;        console.log(result)    &#125;    clear () &#123;        this.#head.next = null        this.#tail = this.#head        this.#currentNode = this.#head        this.#size = 0    &#125;&#125;\n","plink":"https://blog.qoqyir.com/articles/2021/8574f7040288/"},{"title":"Bywave","date":"2021-08-17T15:03:19.000Z","date_formatted":{"ll":"Aug 17, 2021","L":"08/17/2021","MM-DD":"08-17"},"updated":"2021-08-21T10:47:09.114Z","content":"快速便捷，稳定高效 👍\n👇 传送门\n\n该机场分别提供了 vmess、SS、SSR 三种类型的节点，覆盖香港、台湾、日本、美国、新加坡等地区，并且大部分节点为原生 IP 节点。官网同时支持 clash、Shadowrocket 等程序的订阅与一键导入。\n","plink":"https://blog.qoqyir.com/articles/2021/24e9c2e7f1a6/"},{"title":"About (^･o･^)ﾉ","date":"2021-08-21T18:47:09.114Z","date_formatted":{"ll":"Aug 21, 2021","L":"08/21/2021","MM-DD":"08-21"},"updated":"2021-08-21T10:47:09.114Z","content":"I am Qyir. 😃\n\n💬 My Blog: https://blog.qoqyir.com\n👨‍💻 Work in ReroCrode Studio as a designer and engineer\n🏠 Living in Hangzhou, China\n\nTechnology Stack\n  \n   \n \n\nContact me\n   \n","plink":"https://blog.qoqyir.com/about/"}]