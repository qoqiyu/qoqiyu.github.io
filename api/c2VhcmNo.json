[{"title":"Windows文件管理分享（一）| 各类文件夹的认识","date":"2021-08-26T17:41:26.000Z","date_formatted":{"ll":"Aug 26, 2021","L":"08/26/2021","MM-DD":"08-26"},"updated":"2021-08-26T12:53:31.560Z","content":"近来实属无聊，&lt;(￣ c￣)y▂ξ 决定写一篇主观的个人经验分享，打发打发时间。\n\n\n在开始前需要声明一下，本文是基于笔记本电脑和 Windows 系统环境下的分享；另外，之所以限定「笔记本」，主要是我平时笔记本电脑用的多。\n\n\n当然，作为系列的第一期，在分享管理方式之前，我们有必要先了解一下各种文件夹被 Windows 系统创建的目的。\n根目录文件夹\n谈到 Windows 文件管理，绕不开的部分就是磁盘分区。合理的分区可以为一台电脑保持清洁和良好的存储环境，事实上，分区的存在确实就是为优化机械硬盘的存储和读取。\n不过，现在笔记本电脑大多都采用一张大容量（500G、1T 等）固态硬盘的解决方案，此时再考虑分区，基本是出于重装系统和多硬盘。前者是因为在绝大多数人的认知中，重装系统必须清除系统盘，导致系统盘中的数据丢失，实则不然，具体原因稍后谈到用户文件夹时在讲。后者多硬盘分区是必要的，但本文暂不涉及。\n我的电脑装载的是一张 1T 固态硬盘，而分区方案是不额外分区，即 C 盘大一统。我一向推崇 linux 那样的树状结构，说实话非常讨厌 Windows 的文件系统，所以就把 C 盘改名为 root （￣︶￣）↗　。\n\n在 C 盘根目录通常会有几个常驻文件夹，但平时我们不会在根目录下对这些文件夹和文件进行操作，这里只简单介绍一下几个文件夹的作用。\n\n首先是我们可能会去操作的两个 Program Files 文件夹，它们是软件的全局安装目录，当你为软件选择全局安装时，软件就会被安装到这里。两个 Program Files 的区别则是无后缀的存放 64 位软件，有 x86 后缀的存放 32 位软件。\n其次是 Windows 文件夹，这个不用多说大家都明白，系统文件都在里面，如果没有专门学习过相关知识，最好不要动里面的文件。\n然后是 Intel 和 PerfLogs 文件夹，Intel 文件夹中存放的是 intel 芯片相关的日志和更新缓存，可以删除；PerfLogs 文件夹中存放的则是如磁盘扫描记录、程序错误信息等系统日志，可以删除但每次重启都会被重建，它平时的占用也不大，所以建议忽视它。\n还有一个被隐藏的 ProgramData 文件夹，它管理着全局安装软件的配置信息。\n最后是「用户」（英文环境下的 Users）文件夹，它则是所有用户相关文件的入口，也是本系列文章的主要内容。\n至于其他奇奇怪怪的文件夹，基本上都是属于系统或驱动创建的文件夹，更为详细的介绍可以自行搜索。\n「用户」文件夹\n「用户」文件夹中一般会有三个子文件夹：Default、公用（Public）、由用户名称构成的用户文件夹。\n\n\nDefault 文件夹存储着 Windows 系统默认用户配置，当你一个全新的用户身份进入系统，载入的就是该文件夹中的相关配置，但平时与我们无关，可以选择将它隐藏（注意：最好不要删除）；\n公用文件夹如其名字，用于存放公共文件，它是多个用户之间交换文件的中转站，这里涉及 Windows 用户的相关知识，每个用户都会有自己专属的用户文件夹，用户文件夹中的内容只有该用户和拥有权限的用户能够访问，而公用文件夹中的内容是所有用户都能访问的，但对于我们单一用户的电脑基本没啥用处，平时我们也可以将其隐藏；\n用户文件夹，同前文所述，是用户自己专属的文件夹，只有拥有权限才能访问，每当有一个用户登录该设备，系统就会在「用户」文件夹下创建一个以该用户名称构成的用户文件夹（注意：「用户」文件夹指的是根目录中的，用户文件夹指的是由用户名称构成的文件夹）。而我的文件管理方式 90% 的内容基于用户文件夹。\n\n用户文件夹\n打开用户文件夹，首先可以看到各类 Windows 自动创建好的文件夹，如「视频」、「Appdata」、「文档」、「下载」等，这些文件夹在 Windows 中被称为特殊文件夹（或虚拟文件夹），它们采用的是相对路径访问方式，由 %USERPROFILE%（用户文件夹路径）后加对于文件夹名称组成。\n\n\n视频（Videos）、音乐（Music）、图片（Pictures）、3D对象（3D Objects）：这几个文件夹顾名思义，给用户归类存储用的，它们可以被系统内置的播放器、3D查看器与一些第三方的软件主动读取，而我们不用为这些软件指定路径；\n保存的游戏（Saved Games）：该文件夹存放的是微软游戏的相关数据与存档；\n文档（Documents）：用于存放文档的，通常会被各个软件拿来放配置和缓存的，例如某讯某Q的配置信息、聊天记录、文件缓存都是放在文档文件夹中。说实话，按照规范，软件的配置信息和缓存是不应该放在这里的，可是大多软件都不遵守规范，导致这个原本给用户使用的文件夹，现在因为软件们杂乱的文件而不得不被用户弃用……😅\n收藏夹（Favorites）、链接（Links）：这两个文件夹历史遗物属于是，收藏夹最初是和 IE 浏览器配合使用的，IE 的网页收藏和书签就被放在收藏夹里；链接则存放着快速访问的内容，还有从旧版本 Windows 迁移到 Win 10 的收藏夹中的内容，快速访问是 Win 10 用来取代收藏夹的。不过，这两个文件夹现在似乎已经没有用处，大家可以安心删除它们；\n搜索（Searches）：其中存储着系统搜索功能的文件索引，当我们用 Win键 + S 打开「搜索」搜索文件时，它就是依靠该文件夹中的索引文件实现快速搜索的，所以这里面的东西最好不要删除（虽然当我们重新搜索时系统会自动重建索引）；\n桌面（Desktop）：桌面上的所有快捷方式、文件全部都存储在这个文件夹中，如果桌面的文件相当的多，你会发现你的桌面文件夹非常的大。\n下载（Downloads）：存放下载数据，一般附带下载功能的软件默认下载保存的路径就是这里。事实上，我十分建议大家吧所有下载相关的路径都改到这个文件夹中，我见过太多四处存放下载文件让整个磁盘看起来乱糟糟的人，他们常常忘记删除在某处的某个无用下载文件导致硬盘空间不断减少，既然有系统专门规划的下载文件夹，为何不好好利用呢？(￣y▽,￣)╭\nAppData：数据文件夹，里面存放在绝大部分软件的配置和缓存数据。该文件夹中一般有 Local、Locallow、Roaming 三个子文件夹，这些文件夹平时与我们的关系并不大，没啥事我们不会去碰它们，只需要了解几个东西就行了：\n\n当你卸载或删除了某一个软件时，你可以到这三个文件夹中看看有没有存在以你卸载或删除的软件命名相关的文件夹，如果有，你可以安心的去将它们删除，因为那些是软件遗留的数据和缓存；\n在前面说明 Program Files 文件夹时我提到软件的全局安装，既然有全局安装，自然也有与其相对的局部安装，也就是仅为该用户安装，一些软件在安装前都会为我们提供这两个选项，如同全局安装会被默认装到 Program Files，仅为用户安装则会被默认安装到 Local 文件夹下的 Programs 子文件夹；\nAppData 文件夹有时占用会非常的高，其中一大贡献就它底下的 temp 文件，所有以 temp 命名的文件夹基本都是临时文件夹，里面存储着软件的临时数据缓存，所以电脑在使用一段时间后就会积累一堆临时缓存数据，良心一点的软件会在使用完后主动清理临时缓存数据，然而大部分软件可没那么良心……因此我们常常需要到该文件夹中删除无用文件；\n\n\n\n单分区的数据保留\n前文谈论磁盘分区时我说过：\n\n重装系统必须清除系统盘，导致系统盘中的数据丢失，实则不然。\n\n这么说的理由自然是就算不分区使用单分区方案，重装系统时也不会造成数据丢失。重装系统目前主要有两种方式：内部重装和外部重装。\n\n内部重装是通过 Windows 系统内置的重装功能「设置 - 更新和安全 - 恢复 - 重置此电脑」，当你点击开始重装（初始化）系统后，它会弹出一个对话框让你进行选择，其中包括了数据的删除与否，若选择「保留我的文件」选项，重装系统并不会清除用户文件夹中的数据；\n外部重装则是通过一定的外部介质（如 USB、CD 等）载入新系统进行重装，此方式在进入重装引导时依然会有选项可以让你选择是否保留系统盘中用户文件夹的数据；\n\n所以，除非你的硬盘坏了，或者将数据保存在非系统认定的用户文件夹区域，不然现在重装系统基本不会清除用户数据。\n不过嘛，这也只是我个人的推荐，分区也不差，最主要的还是每个人各自的使用习惯。（另外，无论是否分区，备份都是个好东西！！！）\n\n原本打算直接全部写完文件管理方式，但当写好各类文件夹说明后，我发现已经两千多个字了（；´д｀）ゞ，无奈只好分割成一个系列，之后慢慢更新。\n","thumbnail":"https://cdn.jsdelivr.net/gh/Qyir/TuKu/blog/723d164cca129c646a9bb773eda97d53.png","plink":"https://blog.qoqyir.com/articles/2021/e5b609e662dd/"},{"title":"C# 实现链表","date":"2021-08-23T11:05:48.000Z","date_formatted":{"ll":"Aug 23, 2021","L":"08/23/2021","MM-DD":"08-23"},"updated":"2021-08-26T12:53:31.560Z","content":"总结\n之前使用 JS 实现了其不曾内置的链表，这次则是举一反三，通过相同的思想，在 C# 中实现类似的链表，以同样的 Node 节点加 *LinkedList 的结构构建链表。\n\nC# 中存在内置链表，本次实现仅是为了加深对 C# 的使用与理解\n\n代码\nnamespace LinkedList_Implementation &#123;\n\tclass Node &#123;\n\t\tpublic int value;\n\t\tpublic Node next;\n\t\tpublic Node prev;\n\n\t\tpublic Node (int value, Node next = null, Node prev = null) &#123;\n\t\t\tthis.value = value;\n\t\t\tthis.next = next;\n\t\t\tthis.prev = prev;\n\t\t&#125;\n\t&#125;\n\n\tclass SingleLinked &#123;\n\t\tprivate Node _head;\n\t\tprivate Node _tail;\n\t\tprivate Node _currentNode;\n\t\tprivate int _size;\n\t\tpublic SingleLinked (int head) &#123;\n\t\t\t_head = new Node(head);\n\t\t\t_tail = _head;\n\t\t\t_currentNode = _head;\n\t\t\t_size = 0;\n\t\t&#125;\n\n\t\tpublic Node Find (int value) &#123;\n\t\t\t_currentNode = _head;\n\n\t\t\twhile(_currentNode != null &amp;&amp; _currentNode?.value != value) &#123;\n\t\t\t\t_currentNode = _currentNode.next;\n\t\t\t&#125;\n\n\t\t\tif (_currentNode == null) &#123;\n\t\t\t\tConsole.WriteLine(&quot;Node not found&quot;);\n\t\t\t\treturn null;\n\t\t\t&#125;\n\n\t\t\treturn _currentNode;\n\t\t&#125;\n\n\t\tpublic void Add (int value) &#123;\n\t\t\t_currentNode = _tail;\n\t\t\t_currentNode.next = new Node(value);\n\t\t\t_tail = _currentNode.next;\n\t\t\t_tail.prev = _currentNode;\n\t\t\t_size++;\n\t\t&#125;\n\n\t\t// 在指定的 node 前插入 value\n\t\tpublic void Insert (int value, int node) &#123;\n\t\t\t_currentNode = this.Find(node);\n\t\t\tif (_currentNode == null) &#123;\n\t\t\t\tConsole.WriteLine(&quot;Node not found&quot;);\n\t\t\t\treturn;\n\t\t\t&#125;\n\n\t\t\tNode val = new(value);\n\t\t\tval.next = _currentNode;\n\t\t\tval.prev = _currentNode.prev;\n\t\t\t_currentNode.prev.next = val;\n\t\t\t_currentNode.prev = val;\n\t\t\t_size++;\n\t\t&#125;\n\n\t\tpublic void Remove (int value) &#123;\n\t\t\tif (value == _tail.value) &#123;\n\t\t\t\t_currentNode = _tail.prev;\n\t\t\t\t_currentNode.next = null;\n\t\t\t\t_size--;\n\t\t\t&#125;\n\n\t\t\tif (value == _head.value) &#123;\n\t\t\t\tif (_size == 0) &#123;\n\t\t\t\t\treturn;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\t_currentNode = _head;\n\t\t\t\t\t_head.next = null;\n\t\t\t\t\t_size = 0;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\t\t_currentNode = this.Find(value);\n\t\t\tif (_currentNode == null) return;\n\t\t\t_currentNode.prev.next = _currentNode.next;\n\t\t\t_currentNode.next.prev = _currentNode.prev;\n\t\t\t_currentNode = _head;\n\t\t\t_size--;\n\t\t&#125;\n\n\t\tpublic Node Current () &#123;\n\t\t\tConsole.WriteLine(_currentNode.value);\n\t\t\treturn _currentNode;\n\t\t&#125;\n\n\t\tpublic int GetLength () &#123;\n\t\t\treturn _size;\n\t\t&#125;\n\n\t\tpublic void GoToHead () &#123;\n\t\t\t_currentNode = _head;\n\t\t&#125;\n\n\t\tpublic void GoToTail () &#123;\n\t\t\t_currentNode = _tail;\n\t\t&#125;\n\n\t\t// 从指定 node（未指定默认为 _head）为起点向前移动 num 个节点\n\t\tpublic void Forward (int num, int? node = null) &#123;\n\t\t\tif ( node == null) &#123;\n\t\t\t\t_currentNode = _head;\n\t\t\t&#125; else &#123;\n\t\t\t\t_currentNode = this.Find((int)node);\n\t\t\t\tif (_currentNode == null) &#123;\n\t\t\t\t\tConsole.WriteLine(&quot;Node not found&quot;);\n\t\t\t\t\treturn;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\twhile (num-- != 0 &amp; _currentNode.next != null) &#123;\n\t\t\t\t_currentNode = _currentNode.next;\n\t\t\t&#125;\n\t\t\treturn;\n\t\t&#125;\n\n\t\t// 从指定 node（未指定默认为 _tail）为起点向后移动 num 个节点\n\t\tpublic void Back (int num, int? node = null) &#123;\n\t\t\tif (node == null) &#123;\n\t\t\t\t_currentNode = _tail;\n\t\t\t&#125; else &#123;\n\t\t\t\t_currentNode = this.Find((int)node);\n\t\t\t\tif (_currentNode == null) &#123;\n\t\t\t\t\tConsole.WriteLine(&quot;Node not found&quot;);\n\t\t\t\t\treturn;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\twhile (num-- != 0 &amp; _currentNode.prev != null) &#123;\n\t\t\t\t_currentNode = _currentNode.prev;\n\t\t\t&#125;\n\t\t\treturn;\n\t\t&#125;\n\n\t\tpublic void Display () &#123;\n\t\t\tstring result = &quot;&quot;;\n\t\t\t_currentNode = _head;\n\t\t\twhile (_currentNode != null) &#123;\n\t\t\t\tresult += _currentNode.value;\n\t\t\t\t_currentNode = _currentNode.next;\n\t\t\t\tif (_currentNode != null) result += &quot;-&gt;&quot;; \n\t\t\t&#125;\n\t\t\tConsole.WriteLine(result);\n\t\t&#125;\n\t&#125;\n&#125;\n\n","plink":"https://blog.qoqyir.com/articles/2021/2e6f9dcad2ea/"},{"title":"Javascript 实现链表","date":"2021-08-21T18:21:29.000Z","date_formatted":{"ll":"Aug 21, 2021","L":"08/21/2021","MM-DD":"08-21"},"updated":"2021-08-26T12:53:31.560Z","content":"总结\n\n构建一个完整的链表，需要创建两个类：Node 节点类和 *LinkedList 链表类\n如此构建的链表有着快捷的 增 删 查 改 的操作\n但内存消耗大，典型的以时间换空间（next 和 prev 的指针域采用套娃的形式连接每一个节点）\n\n\n代码\nNode 节点类\n12345678910class Node &#123;    constructor(val = 0, next = null, prev = null) &#123;        // 链表数据域        this.val = val        // 链表指针域        this.next = next        // 链表指针域（双向链表）        this.prev = prev    &#125;&#125;\nSingle Linked List 单向链表类\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124class SingleLinkedList &#123;    #head    #currentNode    #size    constructor(head = &#x27;head&#x27;) &#123;        // 表头节点        this.#head = new Node(head)        // 当前节点        this.#currentNode = this.#head        // 链表长度        this.#size = 0    &#125;    // 查找 val 节点    find (val) &#123;        this.#currentNode = this.#head        while (this.#currentNode &amp;&amp; this.#currentNode.val !== val) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    // 查找最后添加的节点    findLasst () &#123;        this.#currentNode = this.#head        while (this.#currentNode.next) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    // 在 prevNode 之后插入 val 节点    insert (val, prevNode) &#123;        this.#currentNode = this.find(prevNode)        if (!this.#currentNode) return console.error(`$&#123;prevNode&#125; is undefined`)        val = new Node(val)        val.next = this.#currentNode.next        this.#currentNode.next = val        this.#size++    &#125;    // 在链表尾部添加 val 节点    append (val) &#123;        this.#currentNode = this.findLasst()        this.#currentNode.next = new Node(val)        this.#size++    &#125;    // 移除 val 节点    remove (val) &#123;        // 移除的节点不存在        if (!this.find(val)) return        // 移除的节点为表头的情况        // 链表长度不为 0 时，直接返回；若删除表头，则将找不到该链表的入口        // 链表长度为 0 时，将表头的 next 指针置空        if (val === this.#head.val) &#123;            if (!this.isEmpty()) &#123;                return            &#125; else &#123;                this.#head.next = null                this.#size = 0                return            &#125;        &#125;        this.#currentNode = this.#head        while (this.#currentNode.next.val !== val) &#123;            if (!this.#currentNode.next) return            this.#currentNode = this.#currentNode.next        &#125;        this.#currentNode.next = this.#currentNode.next.next        this.#size--    &#125;    // 链表是否为空    isEmpty () &#123;        return this.#size === 0    &#125;    // 显示当前的节点    show () &#123;        console.log(this.#currentNode?.val)    &#125;    // 获取链表的长度    getLength () &#123;        return this.#size    &#125;    // 节点指针从 currentNode 位置（默认表头）前进 num 位    forward (num, start) &#123;        this.#currentNode = start ? this.find(start) : this.#currentNode        while (num-- &amp;&amp; this.#currentNode?.next) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    // 返回表头    goToHead () &#123;        this.#currentNode = this.#head    &#125;    // 遍历显示链表    display () &#123;        let result = &#x27;&#x27;        this.#currentNode = this.#head        while (this.#currentNode) &#123;            result += this.#currentNode.val            this.#currentNode = this.#currentNode.next            if (this.#currentNode) result += &#x27;-&gt;&#x27;        &#125;        console.log(result)    &#125;    // 清空链表    clear () &#123;        this.#head.next = null        this.#currentNode = this.#head        this.#size = 0    &#125;&#125;\nDouble Linked List 双向链表类\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137class DoubleLinkedList &#123;    #head    #tail    #currentNode    #size    constructor (head = &#x27;head&#x27;) &#123;        this.#head = new Node(head)        // 表尾        this.#tail = this.#head        this.#currentNode = this.#head        this.#size = 0    &#125;    find (val) &#123;        this.#currentNode = this.#head        while (this.#currentNode &amp;&amp; this.#currentNode.val !== val) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    showLast () &#123;        return this.#tail    &#125;    insert (val, prevNode) &#123;        // preNode 为末尾节点的情况        if (prevNode === this.#tail.val) &#123;            this.#currentNode = new Node(val)            this.#tail.next = this.#currentNode            this.#currentNode.prev = this.#tail            this.#tail = this.#currentNode            this.#size++            return        &#125;        this.#currentNode = this.find(prevNode)        if (!this.#currentNode) return console.error(`$&#123;prevNode&#125; is undefined`)        val = new Node(val)        val.prev = this.#currentNode        val.next = this.#currentNode.next        this.#currentNode.next = val        this.#size++    &#125;    append (val) &#123;        this.#currentNode = new Node(val)        this.#tail.next = this.#currentNode        this.#currentNode.prev = this.#tail        this.#tail = this.#currentNode        this.#size++    &#125;    remove (val) &#123;        // val 节点为末尾的情况        if (val === this.#tail.val) &#123;            this.#currentNode = this.#tail.prev            this.#currentNode.next = null            this.#size--            return        &#125;        if (val === this.#head.val) &#123;            if (!this.isEmpty()) &#123;                return            &#125; else &#123;                this.head.next = null                this.#size = 0                return            &#125;        &#125;        this.#currentNode = this.find(val)        // 移除的节点不存在        if (!this.#currentNode) return        this.#currentNode.next.prev = this.#currentNode.prev        this.#currentNode.prev.next = this.#currentNode.next        this.#size--    &#125;    forward (num, start) &#123;        this.#currentNode = start ? this.find(start) : this.#currentNode        while (num-- &amp;&amp; this.#currentNode?.next) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    back (num, start) &#123;        this.#currentNode = start ? this.find(start) : this.#currentNode        while (num-- &amp;&amp; this.#currentNode?.prev) &#123;            this.#currentNode = this.#currentNode.prev        &#125;        return this.#currentNode    &#125;    goToHead () &#123;        this.#currentNode = this.#head    &#125;    goToTail () &#123;        this.#currentNode = this.#tail    &#125;    isEmpty () &#123;        return this.#size === 0    &#125;    show () &#123;        console.log(this.#currentNode?.val)    &#125;    getLength () &#123;        return this.#size    &#125;    display () &#123;        let result = &#x27;&#x27;        this.#currentNode = this.#head        while (this.#currentNode) &#123;            result += this.#currentNode.val            this.#currentNode = this.#currentNode.next            if (this.#currentNode) result += &#x27;-&gt;&#x27;        &#125;        console.log(result)    &#125;    clear () &#123;        this.#head.next = null        this.#tail = this.#head        this.#currentNode = this.#head        this.#size = 0    &#125;&#125;\n","plink":"https://blog.qoqyir.com/articles/2021/8574f7040288/"},{"title":"Bywave","date":"2021-08-17T15:03:19.000Z","date_formatted":{"ll":"Aug 17, 2021","L":"08/17/2021","MM-DD":"08-17"},"updated":"2021-08-26T12:53:31.560Z","content":"快速便捷，稳定高效 👍\n👇 传送门\n\n该机场分别提供了 vmess、SS、SSR 三种类型的节点，覆盖香港、台湾、日本、美国、新加坡等地区，并且大部分节点为原生 IP 节点。官网同时支持 clash、Shadowrocket 等程序的订阅与一键导入。\n","plink":"https://blog.qoqyir.com/articles/2021/24e9c2e7f1a6/"},{"title":"About (^･o･^)ﾉ","date":"2021-08-26T20:53:31.560Z","date_formatted":{"ll":"Aug 26, 2021","L":"08/26/2021","MM-DD":"08-26"},"updated":"2021-08-26T12:53:31.560Z","content":"I am Qyir. 😃\n\n💬 My Blog: https://blog.qoqyir.com\n👨‍💻 Work in ReroCrode Studio as a designer and engineer\n🏠 Living in Hangzhou, China\n\nTechnology Stack\n  \n   \n \n\nContact me\n   \n","plink":"https://blog.qoqyir.com/about/"}]