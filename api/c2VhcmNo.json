[{"title":"C# 实现链表","date":"2021-08-23T11:05:48.000Z","date_formatted":{"ll":"Aug 23, 2021","L":"08/23/2021","MM-DD":"08-23"},"updated":"2021-08-23T08:07:27.540Z","content":"总结\n之前使用 JS 实现了其不曾内置的链表，这次则是举一反三，通过相同的思想，在 C# 中实现类似的链表，以同样的 Node 节点加 *LinkedList 的结构构建链表。\n\nC# 中存在内置链表，本次实现仅是为了加深对 C# 的使用与理解\n\n代码\nnamespace LinkedList_Implementation &#123;\n\tclass Node &#123;\n\t\tpublic int value;\n\t\tpublic Node next;\n\t\tpublic Node prev;\n\n\t\tpublic Node (int value, Node next = null, Node prev = null) &#123;\n\t\t\tthis.value = value;\n\t\t\tthis.next = next;\n\t\t\tthis.prev = prev;\n\t\t&#125;\n\t&#125;\n\n\tclass SingleLinked &#123;\n\t\tprivate Node _head;\n\t\tprivate Node _tail;\n\t\tprivate Node _currentNode;\n\t\tprivate int _size;\n\t\tpublic SingleLinked (int head) &#123;\n\t\t\t_head = new Node(head);\n\t\t\t_tail = _head;\n\t\t\t_currentNode = _head;\n\t\t\t_size = 0;\n\t\t&#125;\n\n\t\tpublic Node Find (int value) &#123;\n\t\t\t_currentNode = _head;\n\n\t\t\twhile(_currentNode != null &amp;&amp; _currentNode?.value != value) &#123;\n\t\t\t\t_currentNode = _currentNode.next;\n\t\t\t&#125;\n\n\t\t\tif (_currentNode == null) &#123;\n\t\t\t\tConsole.WriteLine(&quot;Node not found&quot;);\n\t\t\t\treturn null;\n\t\t\t&#125;\n\n\t\t\treturn _currentNode;\n\t\t&#125;\n\n\t\tpublic void Add (int value) &#123;\n\t\t\t_currentNode = _tail;\n\t\t\t_currentNode.next = new Node(value);\n\t\t\t_tail = _currentNode.next;\n\t\t\t_tail.prev = _currentNode;\n\t\t\t_size++;\n\t\t&#125;\n\n\t\t// 在指定的 node 前插入 value\n\t\tpublic void Insert (int value, int node) &#123;\n\t\t\t_currentNode = this.Find(node);\n\t\t\tif (_currentNode == null) &#123;\n\t\t\t\tConsole.WriteLine(&quot;Node not found&quot;);\n\t\t\t\treturn;\n\t\t\t&#125;\n\n\t\t\tNode val = new(value);\n\t\t\tval.next = _currentNode;\n\t\t\tval.prev = _currentNode.prev;\n\t\t\t_currentNode.prev.next = val;\n\t\t\t_currentNode.prev = val;\n\t\t\t_size++;\n\t\t&#125;\n\n\t\tpublic void Remove (int value) &#123;\n\t\t\tif (value == _tail.value) &#123;\n\t\t\t\t_currentNode = _tail.prev;\n\t\t\t\t_currentNode.next = null;\n\t\t\t\t_size--;\n\t\t\t&#125;\n\n\t\t\tif (value == _head.value) &#123;\n\t\t\t\tif (_size == 0) &#123;\n\t\t\t\t\treturn;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\t_currentNode = _head;\n\t\t\t\t\t_head.next = null;\n\t\t\t\t\t_size = 0;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\t\t_currentNode = this.Find(value);\n\t\t\tif (_currentNode == null) return;\n\t\t\t_currentNode.prev.next = _currentNode.next;\n\t\t\t_currentNode.next.prev = _currentNode.prev;\n\t\t\t_currentNode = _head;\n\t\t\t_size--;\n\t\t&#125;\n\n\t\tpublic Node Current () &#123;\n\t\t\tConsole.WriteLine(_currentNode.value);\n\t\t\treturn _currentNode;\n\t\t&#125;\n\n\t\tpublic int GetLength () &#123;\n\t\t\treturn _size;\n\t\t&#125;\n\n\t\tpublic void GoToHead () &#123;\n\t\t\t_currentNode = _head;\n\t\t&#125;\n\n\t\tpublic void GoToTail () &#123;\n\t\t\t_currentNode = _tail;\n\t\t&#125;\n\n\t\t// 从指定 node（未指定默认为 _head）为起点向前移动 num 个节点\n\t\tpublic void Forward (int num, int? node = null) &#123;\n\t\t\tif ( node == null) &#123;\n\t\t\t\t_currentNode = _head;\n\t\t\t&#125; else &#123;\n\t\t\t\t_currentNode = this.Find((int)node);\n\t\t\t\tif (_currentNode == null) &#123;\n\t\t\t\t\tConsole.WriteLine(&quot;Node not found&quot;);\n\t\t\t\t\treturn;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\twhile (num-- != 0 &amp; _currentNode.next != null) &#123;\n\t\t\t\t_currentNode = _currentNode.next;\n\t\t\t&#125;\n\t\t\treturn;\n\t\t&#125;\n\n\t\t// 从指定 node（未指定默认为 _tail）为起点向后移动 num 个节点\n\t\tpublic void Back (int num, int? node = null) &#123;\n\t\t\tif (node == null) &#123;\n\t\t\t\t_currentNode = _tail;\n\t\t\t&#125; else &#123;\n\t\t\t\t_currentNode = this.Find((int)node);\n\t\t\t\tif (_currentNode == null) &#123;\n\t\t\t\t\tConsole.WriteLine(&quot;Node not found&quot;);\n\t\t\t\t\treturn;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\twhile (num-- != 0 &amp; _currentNode.prev != null) &#123;\n\t\t\t\t_currentNode = _currentNode.prev;\n\t\t\t&#125;\n\t\t\treturn;\n\t\t&#125;\n\n\t\tpublic void Display () &#123;\n\t\t\tstring result = &quot;&quot;;\n\t\t\t_currentNode = _head;\n\t\t\twhile (_currentNode != null) &#123;\n\t\t\t\tresult += _currentNode.value;\n\t\t\t\t_currentNode = _currentNode.next;\n\t\t\t\tif (_currentNode != null) result += &quot;-&gt;&quot;; \n\t\t\t&#125;\n\t\t\tConsole.WriteLine(result);\n\t\t&#125;\n\t&#125;\n&#125;\n\n","plink":"https://blog.qoqyir.com/articles/2021/2e6f9dcad2ea/"},{"title":"Javascript 实现链表","date":"2021-08-21T18:21:29.000Z","date_formatted":{"ll":"Aug 21, 2021","L":"08/21/2021","MM-DD":"08-21"},"updated":"2021-08-23T08:07:27.540Z","content":"总结\n\n构建一个完整的链表，需要创建两个类：Node 节点类和 *LinkedList 链表类\n如此构建的链表有着快捷的 增 删 查 改 的操作\n但内存消耗大，典型的以时间换空间（next 和 prev 的指针域采用套娃的形式连接每一个节点）\n\n代码\nNode 节点类\n12345678910class Node &#123;    constructor(val = 0, next = null, prev = null) &#123;        // 链表数据域        this.val = val        // 链表指针域        this.next = next        // 链表指针域（双向链表）        this.prev = prev    &#125;&#125;\nSingle Linked List 单向链表类\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124class SingleLinkedList &#123;    #head    #currentNode    #size    constructor(head = &#x27;head&#x27;) &#123;        // 表头节点        this.#head = new Node(head)        // 当前节点        this.#currentNode = this.#head        // 链表长度        this.#size = 0    &#125;    // 查找 val 节点    find (val) &#123;        this.#currentNode = this.#head        while (this.#currentNode &amp;&amp; this.#currentNode.val !== val) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    // 查找最后添加的节点    findLasst () &#123;        this.#currentNode = this.#head        while (this.#currentNode.next) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    // 在 prevNode 之后插入 val 节点    insert (val, prevNode) &#123;        this.#currentNode = this.find(prevNode)        if (!this.#currentNode) return console.error(`$&#123;prevNode&#125; is undefined`)        val = new Node(val)        val.next = this.#currentNode.next        this.#currentNode.next = val        this.#size++    &#125;    // 在链表尾部添加 val 节点    append (val) &#123;        this.#currentNode = this.findLasst()        this.#currentNode.next = new Node(val)        this.#size++    &#125;    // 移除 val 节点    remove (val) &#123;        // 移除的节点不存在        if (!this.find(val)) return        // 移除的节点为表头的情况        // 链表长度不为 0 时，直接返回；若删除表头，则将找不到该链表的入口        // 链表长度为 0 时，将表头的 next 指针置空        if (val === this.#head.val) &#123;            if (!this.isEmpty()) &#123;                return            &#125; else &#123;                this.#head.next = null                this.#size = 0                return            &#125;        &#125;        this.#currentNode = this.#head        while (this.#currentNode.next.val !== val) &#123;            if (!this.#currentNode.next) return            this.#currentNode = this.#currentNode.next        &#125;        this.#currentNode.next = this.#currentNode.next.next        this.#size--    &#125;    // 链表是否为空    isEmpty () &#123;        return this.#size === 0    &#125;    // 显示当前的节点    show () &#123;        console.log(this.#currentNode?.val)    &#125;    // 获取链表的长度    getLength () &#123;        return this.#size    &#125;    // 节点指针从 currentNode 位置（默认表头）前进 num 位    forward (num, start) &#123;        this.#currentNode = start ? this.find(start) : this.#currentNode        while (num-- &amp;&amp; this.#currentNode?.next) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    // 返回表头    goToHead () &#123;        this.#currentNode = this.#head    &#125;    // 遍历显示链表    display () &#123;        let result = &#x27;&#x27;        this.#currentNode = this.#head        while (this.#currentNode) &#123;            result += this.#currentNode.val            this.#currentNode = this.#currentNode.next            if (this.#currentNode) result += &#x27;-&gt;&#x27;        &#125;        console.log(result)    &#125;    // 清空链表    clear () &#123;        this.#head.next = null        this.#currentNode = this.#head        this.#size = 0    &#125;&#125;\nDouble Linked List 双向链表类\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137class DoubleLinkedList &#123;    #head    #tail    #currentNode    #size    constructor (head = &#x27;head&#x27;) &#123;        this.#head = new Node(head)        // 表尾        this.#tail = this.#head        this.#currentNode = this.#head        this.#size = 0    &#125;    find (val) &#123;        this.#currentNode = this.#head        while (this.#currentNode &amp;&amp; this.#currentNode.val !== val) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    showLast () &#123;        return this.#tail    &#125;    insert (val, prevNode) &#123;        // preNode 为末尾节点的情况        if (prevNode === this.#tail.val) &#123;            this.#currentNode = new Node(val)            this.#tail.next = this.#currentNode            this.#currentNode.prev = this.#tail            this.#tail = this.#currentNode            this.#size++            return        &#125;        this.#currentNode = this.find(prevNode)        if (!this.#currentNode) return console.error(`$&#123;prevNode&#125; is undefined`)        val = new Node(val)        val.prev = this.#currentNode        val.next = this.#currentNode.next        this.#currentNode.next = val        this.#size++    &#125;    append (val) &#123;        this.#currentNode = new Node(val)        this.#tail.next = this.#currentNode        this.#currentNode.prev = this.#tail        this.#tail = this.#currentNode        this.#size++    &#125;    remove (val) &#123;        // val 节点为末尾的情况        if (val === this.#tail.val) &#123;            this.#currentNode = this.#tail.prev            this.#currentNode.next = null            this.#size--            return        &#125;        if (val === this.#head.val) &#123;            if (!this.isEmpty()) &#123;                return            &#125; else &#123;                this.head.next = null                this.#size = 0                return            &#125;        &#125;        this.#currentNode = this.find(val)        // 移除的节点不存在        if (!this.#currentNode) return        this.#currentNode.next.prev = this.#currentNode.prev        this.#currentNode.prev.next = this.#currentNode.next        this.#size--    &#125;    forward (num, start) &#123;        this.#currentNode = start ? this.find(start) : this.#currentNode        while (num-- &amp;&amp; this.#currentNode?.next) &#123;            this.#currentNode = this.#currentNode.next        &#125;        return this.#currentNode    &#125;    back (num, start) &#123;        this.#currentNode = start ? this.find(start) : this.#currentNode        while (num-- &amp;&amp; this.#currentNode?.prev) &#123;            this.#currentNode = this.#currentNode.prev        &#125;        return this.#currentNode    &#125;    goToHead () &#123;        this.#currentNode = this.#head    &#125;    goToTail () &#123;        this.#currentNode = this.#tail    &#125;    isEmpty () &#123;        return this.#size === 0    &#125;    show () &#123;        console.log(this.#currentNode?.val)    &#125;    getLength () &#123;        return this.#size    &#125;    display () &#123;        let result = &#x27;&#x27;        this.#currentNode = this.#head        while (this.#currentNode) &#123;            result += this.#currentNode.val            this.#currentNode = this.#currentNode.next            if (this.#currentNode) result += &#x27;-&gt;&#x27;        &#125;        console.log(result)    &#125;    clear () &#123;        this.#head.next = null        this.#tail = this.#head        this.#currentNode = this.#head        this.#size = 0    &#125;&#125;\n","plink":"https://blog.qoqyir.com/articles/2021/8574f7040288/"},{"title":"Bywave","date":"2021-08-17T15:03:19.000Z","date_formatted":{"ll":"Aug 17, 2021","L":"08/17/2021","MM-DD":"08-17"},"updated":"2021-08-23T08:07:27.540Z","content":"快速便捷，稳定高效 👍\n👇 传送门\n\n该机场分别提供了 vmess、SS、SSR 三种类型的节点，覆盖香港、台湾、日本、美国、新加坡等地区，并且大部分节点为原生 IP 节点。官网同时支持 clash、Shadowrocket 等程序的订阅与一键导入。\n","plink":"https://blog.qoqyir.com/articles/2021/24e9c2e7f1a6/"},{"title":"About (^･o･^)ﾉ","date":"2021-08-23T16:07:27.544Z","date_formatted":{"ll":"Aug 23, 2021","L":"08/23/2021","MM-DD":"08-23"},"updated":"2021-08-23T08:07:27.544Z","content":"I am Qyir. 😃\n\n💬 My Blog: https://blog.qoqyir.com\n👨‍💻 Work in ReroCrode Studio as a designer and engineer\n🏠 Living in Hangzhou, China\n\nTechnology Stack\n  \n   \n \n\nContact me\n   \n","plink":"https://blog.qoqyir.com/about/"}]