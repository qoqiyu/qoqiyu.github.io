{"title":"C# 实现链表","date":"2021-08-23T11:05:48.000Z","date_formatted":{"ll":"Aug 23, 2021","L":"08/23/2021","MM-DD":"08-23"},"link":"articles/2021/2e6f9dcad2ea","tags":["C#"],"categories":["技术记录"],"updated":"2021-08-26T12:53:31.560Z","content":"<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>之前使用 JS 实现了其不曾内置的链表，这次则是举一反三，通过相同的思想，在 C# 中实现类似的链表，以同样的 <code>Node</code> 节点加 <code>*LinkedList</code> 的结构构建链表。</p>\n<blockquote>\n<p>C# 中存在内置链表，本次实现仅是为了加深对 C# 的使用与理解</p>\n</blockquote>\n<h2 id=\"代码\">代码<a title=\"#代码\" href=\"#代码\"></a></h2>\n<pre><code class=\"language-CS\">namespace LinkedList_Implementation &#123;\n\tclass Node &#123;\n\t\tpublic int value;\n\t\tpublic Node next;\n\t\tpublic Node prev;\n\n\t\tpublic Node (int value, Node next = null, Node prev = null) &#123;\n\t\t\tthis.value = value;\n\t\t\tthis.next = next;\n\t\t\tthis.prev = prev;\n\t\t&#125;\n\t&#125;\n\n\tclass SingleLinked &#123;\n\t\tprivate Node _head;\n\t\tprivate Node _tail;\n\t\tprivate Node _currentNode;\n\t\tprivate int _size;\n\t\tpublic SingleLinked (int head) &#123;\n\t\t\t_head = new Node(head);\n\t\t\t_tail = _head;\n\t\t\t_currentNode = _head;\n\t\t\t_size = 0;\n\t\t&#125;\n\n\t\tpublic Node Find (int value) &#123;\n\t\t\t_currentNode = _head;\n\n\t\t\twhile(_currentNode != null &amp;&amp; _currentNode?.value != value) &#123;\n\t\t\t\t_currentNode = _currentNode.next;\n\t\t\t&#125;\n\n\t\t\tif (_currentNode == null) &#123;\n\t\t\t\tConsole.WriteLine(&quot;Node not found&quot;);\n\t\t\t\treturn null;\n\t\t\t&#125;\n\n\t\t\treturn _currentNode;\n\t\t&#125;\n\n\t\tpublic void Add (int value) &#123;\n\t\t\t_currentNode = _tail;\n\t\t\t_currentNode.next = new Node(value);\n\t\t\t_tail = _currentNode.next;\n\t\t\t_tail.prev = _currentNode;\n\t\t\t_size++;\n\t\t&#125;\n\n\t\t// 在指定的 node 前插入 value\n\t\tpublic void Insert (int value, int node) &#123;\n\t\t\t_currentNode = this.Find(node);\n\t\t\tif (_currentNode == null) &#123;\n\t\t\t\tConsole.WriteLine(&quot;Node not found&quot;);\n\t\t\t\treturn;\n\t\t\t&#125;\n\n\t\t\tNode val = new(value);\n\t\t\tval.next = _currentNode;\n\t\t\tval.prev = _currentNode.prev;\n\t\t\t_currentNode.prev.next = val;\n\t\t\t_currentNode.prev = val;\n\t\t\t_size++;\n\t\t&#125;\n\n\t\tpublic void Remove (int value) &#123;\n\t\t\tif (value == _tail.value) &#123;\n\t\t\t\t_currentNode = _tail.prev;\n\t\t\t\t_currentNode.next = null;\n\t\t\t\t_size--;\n\t\t\t&#125;\n\n\t\t\tif (value == _head.value) &#123;\n\t\t\t\tif (_size == 0) &#123;\n\t\t\t\t\treturn;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\t_currentNode = _head;\n\t\t\t\t\t_head.next = null;\n\t\t\t\t\t_size = 0;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\t\t_currentNode = this.Find(value);\n\t\t\tif (_currentNode == null) return;\n\t\t\t_currentNode.prev.next = _currentNode.next;\n\t\t\t_currentNode.next.prev = _currentNode.prev;\n\t\t\t_currentNode = _head;\n\t\t\t_size--;\n\t\t&#125;\n\n\t\tpublic Node Current () &#123;\n\t\t\tConsole.WriteLine(_currentNode.value);\n\t\t\treturn _currentNode;\n\t\t&#125;\n\n\t\tpublic int GetLength () &#123;\n\t\t\treturn _size;\n\t\t&#125;\n\n\t\tpublic void GoToHead () &#123;\n\t\t\t_currentNode = _head;\n\t\t&#125;\n\n\t\tpublic void GoToTail () &#123;\n\t\t\t_currentNode = _tail;\n\t\t&#125;\n\n\t\t// 从指定 node（未指定默认为 _head）为起点向前移动 num 个节点\n\t\tpublic void Forward (int num, int? node = null) &#123;\n\t\t\tif ( node == null) &#123;\n\t\t\t\t_currentNode = _head;\n\t\t\t&#125; else &#123;\n\t\t\t\t_currentNode = this.Find((int)node);\n\t\t\t\tif (_currentNode == null) &#123;\n\t\t\t\t\tConsole.WriteLine(&quot;Node not found&quot;);\n\t\t\t\t\treturn;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\twhile (num-- != 0 &amp; _currentNode.next != null) &#123;\n\t\t\t\t_currentNode = _currentNode.next;\n\t\t\t&#125;\n\t\t\treturn;\n\t\t&#125;\n\n\t\t// 从指定 node（未指定默认为 _tail）为起点向后移动 num 个节点\n\t\tpublic void Back (int num, int? node = null) &#123;\n\t\t\tif (node == null) &#123;\n\t\t\t\t_currentNode = _tail;\n\t\t\t&#125; else &#123;\n\t\t\t\t_currentNode = this.Find((int)node);\n\t\t\t\tif (_currentNode == null) &#123;\n\t\t\t\t\tConsole.WriteLine(&quot;Node not found&quot;);\n\t\t\t\t\treturn;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\twhile (num-- != 0 &amp; _currentNode.prev != null) &#123;\n\t\t\t\t_currentNode = _currentNode.prev;\n\t\t\t&#125;\n\t\t\treturn;\n\t\t&#125;\n\n\t\tpublic void Display () &#123;\n\t\t\tstring result = &quot;&quot;;\n\t\t\t_currentNode = _head;\n\t\t\twhile (_currentNode != null) &#123;\n\t\t\t\tresult += _currentNode.value;\n\t\t\t\t_currentNode = _currentNode.next;\n\t\t\t\tif (_currentNode != null) result += &quot;-&gt;&quot;; \n\t\t\t&#125;\n\t\t\tConsole.WriteLine(result);\n\t\t&#125;\n\t&#125;\n&#125;\n</code></pre>\n","prev":{"title":"Windows文件管理分享（一）| 各类文件夹的认识","link":"articles/2021/e5b609e662dd"},"next":{"title":"Javascript 实现链表","link":"articles/2021/8574f7040288"},"plink":"https://blog.qoqyir.com/articles/2021/2e6f9dcad2ea/","toc":[{"id":"总结","title":"总结","index":"1"},{"id":"代码","title":"代码","index":"2"}],"copyright":{"link":"<a href=\"https://blog.qoqyir.com/articles/2021/2e6f9dcad2ea/\" title=\"C# 实现链表\">https://blog.qoqyir.com/articles/2021/2e6f9dcad2ea/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow\" target=\"_blank\">CC BY-NC-ND 4.0</a>)","published":"August 23, 2021"},"reading_time":"462 words in 3 minutes"}